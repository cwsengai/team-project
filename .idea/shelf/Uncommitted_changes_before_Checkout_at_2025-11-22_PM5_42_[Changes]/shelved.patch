Index: src/main/java/entity/TimeInterval.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>package entity;\n\n/**\n * Enum representing time intervals for price data.\n */\npublic enum TimeInterval {\n    Five_Minute,\n    DAILY,\n    WEEKLY,\n    MONTHLY\n}\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/src/main/java/entity/TimeInterval.java b/src/main/java/entity/TimeInterval.java
--- a/src/main/java/entity/TimeInterval.java	(revision 9a29da5965bc6935919a4d7bf65f137acf8f3e8e)
+++ b/src/main/java/entity/TimeInterval.java	(date 1763851234966)
@@ -4,7 +4,7 @@
  * Enum representing time intervals for price data.
  */
 public enum TimeInterval {
-    Five_Minute,
+    FIVE_MINUTES,
     DAILY,
     WEEKLY,
     MONTHLY
Index: src/main/java/interface_adapter/controller/simulated_trading/SimulatedTradingController.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>package interface_adapter.controller.simulated_trading;\nimport entity.PricePoint;\nimport entity.SimulatedOrder;\nimport entity.SimulatedTradeRecord;\nimport use_case.PriceDataAccessInterface;\nimport use_case.price_simulation.PriceSimulationEngine;\nimport use_case.simulated_trade.SimulatedTradeEngine;\nimport entity.TimeInterval;\n\n\nimport java.time.LocalDateTime;\nimport java.util.List;\n\npublic class TradingController {\n    // use case dependencies\n    private final PriceDataAccessInterface priceGateway;\n    private final PriceSimulationEngine simulationEngine;\n    private final SimulatedTradeEngine tradeEngine;\n    //runtime state\n    private SimulatedOrder currentOrder;\n    private List<Double> timeline;\n    private int pointer = 0;  // timeline pointer\n\n    public TradingController(PriceDataAccessInterface priceGateway,\n                             PriceSimulationEngine simulationEngine,\n                             SimulatedTradeEngine tradeEngine) {\n        this.priceGateway = priceGateway;\n        this.simulationEngine = simulationEngine;\n        this.tradeEngine = tradeEngine;\n    }\n\n    //  Smart Buying and Selling\n    public void onBuyOrSell(boolean isBuy, String ticker, int quantity, double limitPrice) {\n        if (currentOrder == null || !currentOrder.isFilled()) {\n            //If there is no current position, buying = going long and selling = going short\n            if (currentOrder == null || !currentOrder.isFilled()) {\n                if (isBuy) {\n                    openLong(ticker, quantity, limitPrice);\n                } else {\n                    openShort(ticker, quantity, limitPrice);\n                }\n                return;\n            }\n            // if currently in a long position: Sell = flat long\n            if (currentOrder.isLong()) {\n                if (!isBuy) {\n                    onClosePosition();\n                }\n            } else {\n                // if currently in a short position: buy = close out\n                if (isBuy) {\n                    onClosePosition();\n                }\n            }\n        }\n    }\n    private void openLong(String ticker, int qty, double limitPrice) {\n        System.out.println(\"Opening LONG position...\");\n        currentOrder = new SimulatedOrder(\n                newOrderId(),\n                ticker,\n                true,   // long\n                qty,\n                limitPrice,\n                LocalDateTime.now()\n        );\n    }\n\n    private void openShort(String ticker, int qty, double limitPrice) {\n        System.out.println(\"Opening SHORT position...\");\n        currentOrder = new SimulatedOrder(\n                newOrderId(),\n                ticker,\n                false,  // short\n                qty,\n                limitPrice,\n                LocalDateTime.now()\n        );\n    }\n    public void onStartSimulation(int compressionFactor) {\n\n        try {\n            //get 5min price\n            List<PricePoint> raw = priceGateway.getPriceHistory(\n                    currentOrder.getTicker(),\n                    TimeInterval.FIVE_MINUTES\n            );\n\n            // Set the compression factor of the price simulator\n            simulationEngine.setCompressionFactor(compressionFactor);\n            simulationEngine.loadRawData(raw);\n\n            // generate timeline\n            this.timeline = simulationEngine.generateTimeline();\n            this.pointer = 0;\n\n            System.out.println(\"Simulation started. Timeline size = \" + timeline.size());\n\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n\n    public void onTick() {\n\n        if (timeline == null || pointer >= timeline.size()) {\n            System.out.println(\"Simulation finished.\");\n            return;\n        }\n\n        double price = timeline.get(pointer);\n        pointer++;\n\n        //  If no transaction is made → Check if the limit price has been triggered\n        if (!currentOrder.isFilled()) {\n            boolean hit = tradeEngine.checkLimitHit(currentOrder, price);\n            if (hit) {\n                currentOrder.setFilled(true);\n                currentOrder.setEntryPrice(price);\n                System.out.println(\">>> ORDER FILLED @\" + price);\n            }\n        }\n\n        // === If the transaction has been completed → Display floating profit and loss ===\n        if (currentOrder.isFilled()) {\n            double pnl = tradeEngine.calculateUnrealizedPnL(currentOrder, price);\n            System.out.println(\"Price: \" + price + \" | PnL: \" + pnl);\n        }\n    }\n    public SimulatedTradeRecord onClosePosition() {\n\n        if (currentOrder == null || !currentOrder.isFilled()) {\n            System.out.println(\"ERROR: No position to close.\");\n            return null;\n        }\n\n        double exitPrice = timeline.get(Math.max(0, pointer - 1));\n        double realized = tradeEngine.calculateRealizedPnL(currentOrder, exitPrice);\n\n        SimulatedTradeRecord record = new SimulatedTradeRecord(\n                currentOrder.getTicker(),\n                currentOrder.isLong(),\n                currentOrder.getQuantity(),\n                currentOrder.getEntryPrice(),\n                exitPrice,\n                realized,\n                currentOrder.getEntryTime(),\n                LocalDateTime.now()\n        );\n\n        System.out.println(\">>> POSITION CLOSED @\" + exitPrice +\n                \"  Realized PnL=\" + realized);\n\n        currentOrder = null;  // reset position\n\n        return record;  // return to history reocrd\n    }\n\n\n\n    private String newOrderId() {\n        return \"ORDER-\" + System.currentTimeMillis();\n    }\n}\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/src/main/java/interface_adapter/controller/simulated_trading/SimulatedTradingController.java b/src/main/java/interface_adapter/controller/simulated_trading/SimulatedTradingController.java
--- a/src/main/java/interface_adapter/controller/simulated_trading/SimulatedTradingController.java	(revision 9a29da5965bc6935919a4d7bf65f137acf8f3e8e)
+++ b/src/main/java/interface_adapter/controller/simulated_trading/SimulatedTradingController.java	(date 1763851195341)
@@ -1,164 +1,164 @@
-package interface_adapter.controller.simulated_trading;
-import entity.PricePoint;
-import entity.SimulatedOrder;
-import entity.SimulatedTradeRecord;
-import use_case.PriceDataAccessInterface;
-import use_case.price_simulation.PriceSimulationEngine;
-import use_case.simulated_trade.SimulatedTradeEngine;
-import entity.TimeInterval;
-
-
-import java.time.LocalDateTime;
-import java.util.List;
-
-public class TradingController {
-    // use case dependencies
-    private final PriceDataAccessInterface priceGateway;
-    private final PriceSimulationEngine simulationEngine;
-    private final SimulatedTradeEngine tradeEngine;
-    //runtime state
-    private SimulatedOrder currentOrder;
-    private List<Double> timeline;
-    private int pointer = 0;  // timeline pointer
-
-    public TradingController(PriceDataAccessInterface priceGateway,
-                             PriceSimulationEngine simulationEngine,
-                             SimulatedTradeEngine tradeEngine) {
-        this.priceGateway = priceGateway;
-        this.simulationEngine = simulationEngine;
-        this.tradeEngine = tradeEngine;
-    }
-
-    //  Smart Buying and Selling
-    public void onBuyOrSell(boolean isBuy, String ticker, int quantity, double limitPrice) {
-        if (currentOrder == null || !currentOrder.isFilled()) {
-            //If there is no current position, buying = going long and selling = going short
-            if (currentOrder == null || !currentOrder.isFilled()) {
-                if (isBuy) {
-                    openLong(ticker, quantity, limitPrice);
-                } else {
-                    openShort(ticker, quantity, limitPrice);
-                }
-                return;
-            }
-            // if currently in a long position: Sell = flat long
-            if (currentOrder.isLong()) {
-                if (!isBuy) {
-                    onClosePosition();
-                }
-            } else {
-                // if currently in a short position: buy = close out
-                if (isBuy) {
-                    onClosePosition();
-                }
-            }
-        }
-    }
-    private void openLong(String ticker, int qty, double limitPrice) {
-        System.out.println("Opening LONG position...");
-        currentOrder = new SimulatedOrder(
-                newOrderId(),
-                ticker,
-                true,   // long
-                qty,
-                limitPrice,
-                LocalDateTime.now()
-        );
-    }
-
-    private void openShort(String ticker, int qty, double limitPrice) {
-        System.out.println("Opening SHORT position...");
-        currentOrder = new SimulatedOrder(
-                newOrderId(),
-                ticker,
-                false,  // short
-                qty,
-                limitPrice,
-                LocalDateTime.now()
-        );
-    }
-    public void onStartSimulation(int compressionFactor) {
-
-        try {
-            //get 5min price
-            List<PricePoint> raw = priceGateway.getPriceHistory(
-                    currentOrder.getTicker(),
-                    TimeInterval.FIVE_MINUTES
-            );
-
-            // Set the compression factor of the price simulator
-            simulationEngine.setCompressionFactor(compressionFactor);
-            simulationEngine.loadRawData(raw);
-
-            // generate timeline
-            this.timeline = simulationEngine.generateTimeline();
-            this.pointer = 0;
-
-            System.out.println("Simulation started. Timeline size = " + timeline.size());
-
-        } catch (Exception e) {
-            e.printStackTrace();
-        }
-    }
-
-    public void onTick() {
-
-        if (timeline == null || pointer >= timeline.size()) {
-            System.out.println("Simulation finished.");
-            return;
-        }
-
-        double price = timeline.get(pointer);
-        pointer++;
-
-        //  If no transaction is made → Check if the limit price has been triggered
-        if (!currentOrder.isFilled()) {
-            boolean hit = tradeEngine.checkLimitHit(currentOrder, price);
-            if (hit) {
-                currentOrder.setFilled(true);
-                currentOrder.setEntryPrice(price);
-                System.out.println(">>> ORDER FILLED @" + price);
-            }
-        }
-
-        // === If the transaction has been completed → Display floating profit and loss ===
-        if (currentOrder.isFilled()) {
-            double pnl = tradeEngine.calculateUnrealizedPnL(currentOrder, price);
-            System.out.println("Price: " + price + " | PnL: " + pnl);
-        }
-    }
-    public SimulatedTradeRecord onClosePosition() {
-
-        if (currentOrder == null || !currentOrder.isFilled()) {
-            System.out.println("ERROR: No position to close.");
-            return null;
-        }
-
-        double exitPrice = timeline.get(Math.max(0, pointer - 1));
-        double realized = tradeEngine.calculateRealizedPnL(currentOrder, exitPrice);
-
-        SimulatedTradeRecord record = new SimulatedTradeRecord(
-                currentOrder.getTicker(),
-                currentOrder.isLong(),
-                currentOrder.getQuantity(),
-                currentOrder.getEntryPrice(),
-                exitPrice,
-                realized,
-                currentOrder.getEntryTime(),
-                LocalDateTime.now()
-        );
-
-        System.out.println(">>> POSITION CLOSED @" + exitPrice +
-                "  Realized PnL=" + realized);
-
-        currentOrder = null;  // reset position
-
-        return record;  // return to history reocrd
-    }
-
-
-
-    private String newOrderId() {
-        return "ORDER-" + System.currentTimeMillis();
-    }
-}
+//package interface_adapter.controller.simulated_trading;
+//import entity.PricePoint;
+//import entity.SimulatedOrder;
+//import entity.SimulatedTradeRecord;
+//import use_case.PriceDataAccessInterface;
+//import use_case.price_simulation.PriceSimulationEngine;
+//import use_case.simulated_trade.SimulatedTradeEngine;
+//import entity.TimeInterval;
+//
+//
+//import java.time.LocalDateTime;
+//import java.util.List;
+//
+//public class TradingController {
+//    // use case dependencies
+//    private final PriceDataAccessInterface priceGateway;
+//    private final PriceSimulationEngine simulationEngine;
+//    private final SimulatedTradeEngine tradeEngine;
+//    //runtime state
+//    private SimulatedOrder currentOrder;
+//    private List<Double> timeline;
+//    private int pointer = 0;  // timeline pointer
+//
+//    public TradingController(PriceDataAccessInterface priceGateway,
+//                             PriceSimulationEngine simulationEngine,
+//                             SimulatedTradeEngine tradeEngine) {
+//        this.priceGateway = priceGateway;
+//        this.simulationEngine = simulationEngine;
+//        this.tradeEngine = tradeEngine;
+//    }
+//
+//    //  Smart Buying and Selling
+//    public void onBuyOrSell(boolean isBuy, String ticker, int quantity, double limitPrice) {
+//        if (currentOrder == null || !currentOrder.isFilled()) {
+//            //If there is no current position, buying = going long and selling = going short
+//            if (currentOrder == null || !currentOrder.isFilled()) {
+//                if (isBuy) {
+//                    openLong(ticker, quantity, limitPrice);
+//                } else {
+//                    openShort(ticker, quantity, limitPrice);
+//                }
+//                return;
+//            }
+//            // if currently in a long position: Sell = flat long
+//            if (currentOrder.isLong()) {
+//                if (!isBuy) {
+//                    onClosePosition();
+//                }
+//            } else {
+//                // if currently in a short position: buy = close out
+//                if (isBuy) {
+//                    onClosePosition();
+//                }
+//            }
+//        }
+//    }
+//    private void openLong(String ticker, int qty, double limitPrice) {
+//        System.out.println("Opening LONG position...");
+//        currentOrder = new SimulatedOrder(
+//                newOrderId(),
+//                ticker,
+//                true,   // long
+//                qty,
+//                limitPrice,
+//                LocalDateTime.now()
+//        );
+//    }
+//
+//    private void openShort(String ticker, int qty, double limitPrice) {
+//        System.out.println("Opening SHORT position...");
+//        currentOrder = new SimulatedOrder(
+//                newOrderId(),
+//                ticker,
+//                false,  // short
+//                qty,
+//                limitPrice,
+//                LocalDateTime.now()
+//        );
+//    }
+//    public void onStartSimulation(int compressionFactor) {
+//
+//        try {
+//            //get 5min price
+//            List<PricePoint> raw = priceGateway.getPriceHistory(
+//                    currentOrder.getTicker(),
+//                    TimeInterval.FIVE_MINUTES
+//            );
+//
+//            // Set the compression factor of the price simulator
+//            simulationEngine.setCompressionFactor(compressionFactor);
+//            simulationEngine.loadRawData(raw);
+//
+//            // generate timeline
+//            this.timeline = simulationEngine.generateTimeline();
+//            this.pointer = 0;
+//
+//            System.out.println("Simulation started. Timeline size = " + timeline.size());
+//
+//        } catch (Exception e) {
+//            e.printStackTrace();
+//        }
+//    }
+//
+//    public void onTick() {
+//
+//        if (timeline == null || pointer >= timeline.size()) {
+//            System.out.println("Simulation finished.");
+//            return;
+//        }
+//
+//        double price = timeline.get(pointer);
+//        pointer++;
+//
+//        //  If no transaction is made → Check if the limit price has been triggered
+//        if (!currentOrder.isFilled()) {
+//            boolean hit = tradeEngine.checkLimitHit(currentOrder, price);
+//            if (hit) {
+//                currentOrder.setFilled(true);
+//                currentOrder.setEntryPrice(price);
+//                System.out.println(">>> ORDER FILLED @" + price);
+//            }
+//        }
+//
+//        // === If the transaction has been completed → Display floating profit and loss ===
+//        if (currentOrder.isFilled()) {
+//            double pnl = tradeEngine.calculateUnrealizedPnL(currentOrder, price);
+//            System.out.println("Price: " + price + " | PnL: " + pnl);
+//        }
+//    }
+//    public SimulatedTradeRecord onClosePosition() {
+//
+//        if (currentOrder == null || !currentOrder.isFilled()) {
+//            System.out.println("ERROR: No position to close.");
+//            return null;
+//        }
+//
+//        double exitPrice = timeline.get(Math.max(0, pointer - 1));
+//        double realized = tradeEngine.calculateRealizedPnL(currentOrder, exitPrice);
+//
+//        SimulatedTradeRecord record = new SimulatedTradeRecord(
+//                currentOrder.getTicker(),
+//                currentOrder.isLong(),
+//                currentOrder.getQuantity(),
+//                currentOrder.getEntryPrice(),
+//                exitPrice,
+//                realized,
+//                currentOrder.getEntryTime(),
+//                LocalDateTime.now()
+//        );
+//
+//        System.out.println(">>> POSITION CLOSED @" + exitPrice +
+//                "  Realized PnL=" + realized);
+//
+//        currentOrder = null;  // reset position
+//
+//        return record;  // return to history reocrd
+//    }
+//
+//
+//
+//    private String newOrderId() {
+//        return "ORDER-" + System.currentTimeMillis();
+//    }
+//}
Index: src/main/java/interface_adapter/IntervalController.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>package interface_adapter;\n\nimport entity.TimeInterval;\nimport use_case.PriceInputBoundary;\n\npublic class IntervalController {\n\n    private final PriceInputBoundary priceInteractor;\n    private String currentTicker = \"AAPL\"; // Default ticker\n\n    public IntervalController(PriceInputBoundary interactor) {\n        this.priceInteractor = interactor;\n    }\n\n    public void setCurrentTicker(String ticker) {\n        this.currentTicker = ticker;\n    }\n\n    public void handleTimeChange(String buttonText) {\n        TimeInterval interval = null;\n\n        switch (buttonText) {\n            case \"5M\":\n            case \"5min\":\n                interval = TimeInterval.INTRADAY;\n                break;\n            case \"1D\":\n            case \"1 day\":\n                interval = TimeInterval.DAILY;\n                break;\n            case \"1W\":\n            case \"1 week\":\n                interval = TimeInterval.WEEKLY;\n                break;\n            default:\n                System.err.println(\"ERROR: Unsupported time interval button: \" + buttonText);\n                break;\n        }\n\n        if (interval != null && currentTicker != null) {\n            System.out.println(\"INFO: Requesting price history for \" + currentTicker + \" with interval \" + interval);\n            this.priceInteractor.loadPriceHistory(currentTicker, interval);\n        }\n    }\n}
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/src/main/java/interface_adapter/IntervalController.java b/src/main/java/interface_adapter/IntervalController.java
--- a/src/main/java/interface_adapter/IntervalController.java	(revision 9a29da5965bc6935919a4d7bf65f137acf8f3e8e)
+++ b/src/main/java/interface_adapter/IntervalController.java	(date 1763851273378)
@@ -22,7 +22,7 @@
         switch (buttonText) {
             case "5M":
             case "5min":
-                interval = TimeInterval.INTRADAY;
+                interval = TimeInterval.FIVE_MINUTES;
                 break;
             case "1D":
             case "1 day":
Index: src/main/java/app/Main.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>package app;\n\nimport java.time.LocalDateTime;\n\nimport javax.swing.SwingUtilities;\n\nimport data_access.AlphaVantageGateway;\nimport data_access.InMemoryPortfolioRepository;\nimport data_access.PortfolioRepository;\nimport data_access.StockDataGateway;\nimport entity.Portfolio;\nimport entity.Position;\nimport entity.Trade;\nimport interface_adapter.controller.TradingController;\nimport interface_adapter.presenter.PortfolioPresenter;\nimport use_case.track_portfolio.TrackPortfolioInteractor;\nimport view.MainFrame;\nimport view.PortfolioPage;\n\n/**\n * The Main class is the entry point of the application.\n * Sets up dependency injection and wires all components together.\n */\npublic class Main {\n    public static void main(String[] args) {\n        // Use SwingUtilities.invokeLater to ensure thread safety\n        SwingUtilities.invokeLater(() -> {\n            // Initialize the application with Clean Architecture components\n            MainFrame frame = createApplication();\n            frame.setVisible(true);\n        });\n    }\n\n    /**\n     * Create and wire up all application components.\n     * This is where dependency injection happens following the Dependency Inversion Principle.\n     * All components depend on abstractions, not concretions.\n     */\n    private static MainFrame createApplication() {\n        // TODO: Replace hardcoded values with configuration\n        String portfolioId = \"portfolio-001\";\n        String userId = \"user-001\";\n\n        // === Data Access Layer ===\n        // Create repository (in-memory for now)\n        PortfolioRepository portfolioRepository = new InMemoryPortfolioRepository();\n        \n        // Create stock data gateway\n        // TODO: Replace with actual API key from configuration\n        StockDataGateway stockDataGateway = new AlphaVantageGateway(\"DEMO_API_KEY\");\n\n        // === Create sample portfolio for demo ===\n        createSamplePortfolio(portfolioRepository, portfolioId, userId);\n\n        // === Create main frame ===\n        MainFrame frame = new MainFrame();\n        \n        // === Wire dependencies using interfaces (following DIP) ===\n        // Create view (concrete implementation but will be used through interface)\n        PortfolioPage portfolioPage = new PortfolioPage(null, portfolioId, userId);\n        \n        // Create presenter (depends on PortfolioView interface, not concrete PortfolioPage)\n        PortfolioPresenter presenter = new PortfolioPresenter(portfolioPage);\n        \n        // Create interactor (depends on interfaces)\n        TrackPortfolioInteractor interactor = new TrackPortfolioInteractor(\n                portfolioRepository, stockDataGateway, presenter);\n        \n        // Create controller (depends on use case interface)\n        TradingController controller = new TradingController(interactor);\n        \n        // Set the controller on the view\n        portfolioPage.setController(controller);\n        \n        // Add portfolio page to frame\n        frame.setContentPane(portfolioPage);\n\n        // Load initial portfolio data\n        controller.viewPortfolio(portfolioId, userId);\n\n        return frame;\n    }\n\n    /**\n     * Create a sample portfolio with some positions for demonstration.\n     * TODO: Remove this and implement proper portfolio creation UI\n     */\n    private static void createSamplePortfolio(PortfolioRepository repository, \n                                              String portfolioId, String userId) {\n        Portfolio portfolio = new Portfolio(portfolioId, userId, 10000.0);\n\n        // Add sample positions\n        // AAPL position\n        Position aaplPosition = new Position(\"AAPL\");\n        aaplPosition.addTrade(new Trade(\"T001\", \"AAPL\", 10, 150.0, \n                LocalDateTime.now().minusDays(30), true));\n        portfolio.addPosition(aaplPosition);\n\n        // GOOGL position\n        Position googlPosition = new Position(\"GOOGL\");\n        googlPosition.addTrade(new Trade(\"T002\", \"GOOGL\", 5, 130.0, \n                LocalDateTime.now().minusDays(20), true));\n        portfolio.addPosition(googlPosition);\n\n        // MSFT position\n        Position msftPosition = new Position(\"MSFT\");\n        msftPosition.addTrade(new Trade(\"T003\", \"MSFT\", 8, 350.0, \n                LocalDateTime.now().minusDays(15), true));\n        portfolio.addPosition(msftPosition);\n\n        // Save to repository\n        repository.save(portfolio);\n    }\n\n    /**\n     * TODO: Add configuration loading (API keys, database connections, etc.)\n     * TODO: Add proper dependency injection framework (e.g., Spring, Guice)\n     * TODO: Add logging configuration\n     * TODO: Add error handling for initialization failures\n     * TODO: Add command-line argument parsing for different modes (demo, production, etc.)\n     */\n}\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/src/main/java/app/Main.java b/src/main/java/app/Main.java
--- a/src/main/java/app/Main.java	(revision 9a29da5965bc6935919a4d7bf65f137acf8f3e8e)
+++ b/src/main/java/app/Main.java	(date 1763851178441)
@@ -1,122 +1,122 @@
-package app;
-
-import java.time.LocalDateTime;
-
-import javax.swing.SwingUtilities;
-
-import data_access.AlphaVantageGateway;
-import data_access.InMemoryPortfolioRepository;
-import data_access.PortfolioRepository;
-import data_access.StockDataGateway;
-import entity.Portfolio;
-import entity.Position;
-import entity.Trade;
-import interface_adapter.controller.TradingController;
-import interface_adapter.presenter.PortfolioPresenter;
-import use_case.track_portfolio.TrackPortfolioInteractor;
-import view.MainFrame;
-import view.PortfolioPage;
-
-/**
- * The Main class is the entry point of the application.
- * Sets up dependency injection and wires all components together.
- */
-public class Main {
-    public static void main(String[] args) {
-        // Use SwingUtilities.invokeLater to ensure thread safety
-        SwingUtilities.invokeLater(() -> {
-            // Initialize the application with Clean Architecture components
-            MainFrame frame = createApplication();
-            frame.setVisible(true);
-        });
-    }
-
-    /**
-     * Create and wire up all application components.
-     * This is where dependency injection happens following the Dependency Inversion Principle.
-     * All components depend on abstractions, not concretions.
-     */
-    private static MainFrame createApplication() {
-        // TODO: Replace hardcoded values with configuration
-        String portfolioId = "portfolio-001";
-        String userId = "user-001";
-
-        // === Data Access Layer ===
-        // Create repository (in-memory for now)
-        PortfolioRepository portfolioRepository = new InMemoryPortfolioRepository();
-        
-        // Create stock data gateway
-        // TODO: Replace with actual API key from configuration
-        StockDataGateway stockDataGateway = new AlphaVantageGateway("DEMO_API_KEY");
-
-        // === Create sample portfolio for demo ===
-        createSamplePortfolio(portfolioRepository, portfolioId, userId);
-
-        // === Create main frame ===
-        MainFrame frame = new MainFrame();
-        
-        // === Wire dependencies using interfaces (following DIP) ===
-        // Create view (concrete implementation but will be used through interface)
-        PortfolioPage portfolioPage = new PortfolioPage(null, portfolioId, userId);
-        
-        // Create presenter (depends on PortfolioView interface, not concrete PortfolioPage)
-        PortfolioPresenter presenter = new PortfolioPresenter(portfolioPage);
-        
-        // Create interactor (depends on interfaces)
-        TrackPortfolioInteractor interactor = new TrackPortfolioInteractor(
-                portfolioRepository, stockDataGateway, presenter);
-        
-        // Create controller (depends on use case interface)
-        TradingController controller = new TradingController(interactor);
-        
-        // Set the controller on the view
-        portfolioPage.setController(controller);
-        
-        // Add portfolio page to frame
-        frame.setContentPane(portfolioPage);
-
-        // Load initial portfolio data
-        controller.viewPortfolio(portfolioId, userId);
-
-        return frame;
-    }
-
-    /**
-     * Create a sample portfolio with some positions for demonstration.
-     * TODO: Remove this and implement proper portfolio creation UI
-     */
-    private static void createSamplePortfolio(PortfolioRepository repository, 
-                                              String portfolioId, String userId) {
-        Portfolio portfolio = new Portfolio(portfolioId, userId, 10000.0);
-
-        // Add sample positions
-        // AAPL position
-        Position aaplPosition = new Position("AAPL");
-        aaplPosition.addTrade(new Trade("T001", "AAPL", 10, 150.0, 
-                LocalDateTime.now().minusDays(30), true));
-        portfolio.addPosition(aaplPosition);
-
-        // GOOGL position
-        Position googlPosition = new Position("GOOGL");
-        googlPosition.addTrade(new Trade("T002", "GOOGL", 5, 130.0, 
-                LocalDateTime.now().minusDays(20), true));
-        portfolio.addPosition(googlPosition);
-
-        // MSFT position
-        Position msftPosition = new Position("MSFT");
-        msftPosition.addTrade(new Trade("T003", "MSFT", 8, 350.0, 
-                LocalDateTime.now().minusDays(15), true));
-        portfolio.addPosition(msftPosition);
-
-        // Save to repository
-        repository.save(portfolio);
-    }
-
-    /**
-     * TODO: Add configuration loading (API keys, database connections, etc.)
-     * TODO: Add proper dependency injection framework (e.g., Spring, Guice)
-     * TODO: Add logging configuration
-     * TODO: Add error handling for initialization failures
-     * TODO: Add command-line argument parsing for different modes (demo, production, etc.)
-     */
-}
+//package app;
+//
+//import java.time.LocalDateTime;
+//
+//import javax.swing.SwingUtilities;
+//
+//import data_access.AlphaVantageGateway;
+//import data_access.InMemoryPortfolioRepository;
+//import data_access.PortfolioRepository;
+//import data_access.StockDataGateway;
+//import entity.Portfolio;
+//import entity.Position;
+//import entity.Trade;
+//import interface_adapter.controller.TradingController;
+//import interface_adapter.presenter.PortfolioPresenter;
+//import use_case.track_portfolio.TrackPortfolioInteractor;
+//import view.MainFrame;
+//import view.PortfolioPage;
+//
+///**
+// * The Main class is the entry point of the application.
+// * Sets up dependency injection and wires all components together.
+// */
+//public class Main {
+//    public static void main(String[] args) {
+//        // Use SwingUtilities.invokeLater to ensure thread safety
+//        SwingUtilities.invokeLater(() -> {
+//            // Initialize the application with Clean Architecture components
+//            MainFrame frame = createApplication();
+//            frame.setVisible(true);
+//        });
+//    }
+//
+//    /**
+//     * Create and wire up all application components.
+//     * This is where dependency injection happens following the Dependency Inversion Principle.
+//     * All components depend on abstractions, not concretions.
+//     */
+//    private static MainFrame createApplication() {
+//        // TODO: Replace hardcoded values with configuration
+//        String portfolioId = "portfolio-001";
+//        String userId = "user-001";
+//
+//        // === Data Access Layer ===
+//        // Create repository (in-memory for now)
+//        PortfolioRepository portfolioRepository = new InMemoryPortfolioRepository();
+//
+//        // Create stock data gateway
+//        // TODO: Replace with actual API key from configuration
+//        StockDataGateway stockDataGateway = new AlphaVantageGateway("DEMO_API_KEY");
+//
+//        // === Create sample portfolio for demo ===
+//        createSamplePortfolio(portfolioRepository, portfolioId, userId);
+//
+//        // === Create main frame ===
+//        MainFrame frame = new MainFrame();
+//
+//        // === Wire dependencies using interfaces (following DIP) ===
+//        // Create view (concrete implementation but will be used through interface)
+//        PortfolioPage portfolioPage = new PortfolioPage(null, portfolioId, userId);
+//
+//        // Create presenter (depends on PortfolioView interface, not concrete PortfolioPage)
+//        PortfolioPresenter presenter = new PortfolioPresenter(portfolioPage);
+//
+//        // Create interactor (depends on interfaces)
+//        TrackPortfolioInteractor interactor = new TrackPortfolioInteractor(
+//                portfolioRepository, stockDataGateway, presenter);
+//
+//        // Create controller (depends on use case interface)
+//        TradingController controller = new TradingController(interactor);
+//
+//        // Set the controller on the view
+//        portfolioPage.setController(controller);
+//
+//        // Add portfolio page to frame
+//        frame.setContentPane(portfolioPage);
+//
+//        // Load initial portfolio data
+//        controller.viewPortfolio(portfolioId, userId);
+//
+//        return frame;
+//    }
+//
+//    /**
+//     * Create a sample portfolio with some positions for demonstration.
+//     * TODO: Remove this and implement proper portfolio creation UI
+//     */
+//    private static void createSamplePortfolio(PortfolioRepository repository,
+//                                              String portfolioId, String userId) {
+//        Portfolio portfolio = new Portfolio(portfolioId, userId, 10000.0);
+//
+//        // Add sample positions
+//        // AAPL position
+//        Position aaplPosition = new Position("AAPL");
+//        aaplPosition.addTrade(new Trade("T001", "AAPL", 10, 150.0,
+//                LocalDateTime.now().minusDays(30), true));
+//        portfolio.addPosition(aaplPosition);
+//
+//        // GOOGL position
+//        Position googlPosition = new Position("GOOGL");
+//        googlPosition.addTrade(new Trade("T002", "GOOGL", 5, 130.0,
+//                LocalDateTime.now().minusDays(20), true));
+//        portfolio.addPosition(googlPosition);
+//
+//        // MSFT position
+//        Position msftPosition = new Position("MSFT");
+//        msftPosition.addTrade(new Trade("T003", "MSFT", 8, 350.0,
+//                LocalDateTime.now().minusDays(15), true));
+//        portfolio.addPosition(msftPosition);
+//
+//        // Save to repository
+//        repository.save(portfolio);
+//    }
+//
+//    /**
+//     * TODO: Add configuration loading (API keys, database connections, etc.)
+//     * TODO: Add proper dependency injection framework (e.g., Spring, Guice)
+//     * TODO: Add logging configuration
+//     * TODO: Add error handling for initialization failures
+//     * TODO: Add command-line argument parsing for different modes (demo, production, etc.)
+//     */
+//}
Index: src/main/java/framework_and_driver/ChartPanel.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>package framework_and_driver;\n\nimport java.awt.BorderLayout;\nimport java.awt.Color;\nimport java.util.ArrayList;\nimport java.util.List;\n\nimport javax.swing.BorderFactory;\nimport javax.swing.JLabel;\nimport javax.swing.JPanel;\nimport javax.swing.SwingConstants;\n\nimport org.knowm.xchart.CategoryChart;\nimport org.knowm.xchart.CategoryChartBuilder;\nimport org.knowm.xchart.XChartPanel;\n\nimport entity.ChartViewModel;\nimport entity.TimeInterval;\n\n/**\n * Reusable chart panel component that can be used in any Swing container.\n * Supports both line charts and candlestick charts.\n */\npublic class ChartPanel extends JPanel {\n\n    private JPanel chartContainer;\n\n    public ChartPanel() {\n        setLayout(new BorderLayout());\n        setBorder(BorderFactory.createEmptyBorder(5, 5, 5, 5));\n        setBackground(Color.WHITE);\n        \n        chartContainer = new JPanel(new BorderLayout());\n        chartContainer.setBackground(Color.WHITE);\n        \n        // Initialize with placeholder\n        JLabel placeholder = new JLabel(\"<html><div style='text-align: center; padding: 20px;'>\" +\n                \"<p>\uD83D\uDCCA Loading chart data...</p></div></html>\", SwingConstants.CENTER);\n        chartContainer.add(placeholder, BorderLayout.CENTER);\n        add(chartContainer, BorderLayout.CENTER);\n    }\n\n    /**\n     * Update chart data\n     * @param viewModel Chart view model\n     */\n    public void updateChart(ChartViewModel viewModel) {\n        // Remove existing chart\n        chartContainer.removeAll();\n        \n        try {\n            if (viewModel.isCandlestick()) {\n                // Create candlestick chart (using CategoryChart with multiple series)\n                CategoryChart chart = createCandlestickChart(viewModel);\n                XChartPanel<CategoryChart> chartPanelComponent = new XChartPanel<>(chart);\n                chartContainer.add(chartPanelComponent, BorderLayout.CENTER);\n            } else {\n                // Create line chart\n                CategoryChart chart = createLineChart(viewModel);\n                XChartPanel<CategoryChart> chartPanelComponent = new XChartPanel<>(chart);\n                chartContainer.add(chartPanelComponent, BorderLayout.CENTER);\n            }\n            \n            chartContainer.revalidate();\n            chartContainer.repaint();\n        } catch (Exception e) {\n            JLabel errorLabel = new JLabel(\"<html><div style='text-align: center; padding: 20px; color: red;'>\" +\n                    \"<p>Chart Rendering Error: \" + e.getMessage() + \"</p></div></html>\", \n                    SwingConstants.CENTER);\n            chartContainer.add(errorLabel, BorderLayout.CENTER);\n            chartContainer.revalidate();\n            chartContainer.repaint();\n        }\n    }\n\n    /**\n     * Clear the chart\n     */\n    public void clearChart() {\n        chartContainer.removeAll();\n        JLabel placeholder = new JLabel(\"<html><div style='text-align: center; padding: 20px;'>\" +\n                \"<p>\uD83D\uDCCA Loading chart data...</p></div></html>\", SwingConstants.CENTER);\n        chartContainer.add(placeholder, BorderLayout.CENTER);\n        chartContainer.revalidate();\n        chartContainer.repaint();\n    }\n\n    private CategoryChart createLineChart(ChartViewModel viewModel) {\n        CategoryChart chart = new CategoryChartBuilder()\n                .width(getWidth() > 0 ? getWidth() - 20 : 600)\n                .height(getHeight() > 0 ? getHeight() - 20 : 400)\n                .title(viewModel.getTitle())\n                .xAxisTitle(\"Date\")\n                .yAxisTitle(\"Price (USD)\")\n                .build();\n\n        // Customize chart with line chart specific styling\n        ChartStyler.applyLineChartStyle(chart);\n\n        // Convert labels and prices to arrays\n        List<String> labels = viewModel.getLabels();\n        List<Double> prices = viewModel.getPrices();\n        \n        // Sample data points based on time interval for better visualization\n        int dataSize = labels.size();\n        List<String> displayLabels = new ArrayList<>();\n        List<Double> displayPrices = new ArrayList<>();\n        \n        // Determine max points based on interval\n        int maxPoints;\n        TimeInterval interval = viewModel.getInterval();\n        if (interval != null) {\n            switch (interval) {\n                case INTRADAY: // 5 minutes - show more detail\n                    maxPoints = 500;\n                    break;\n                case DAILY: // Daily - show moderate detail\n                    maxPoints = 100;\n                    break;\n                case WEEKLY: // Weekly - show less detail\n                    maxPoints = 50;\n                    break;\n                case MONTHLY: // Monthly - show minimal detail\n                    maxPoints = 30;\n                    break;\n                default:\n                    maxPoints = 200;\n            }\n        } else {\n            maxPoints = 200; // Default\n        }\n        \n        // Sample data points if needed\n        if (dataSize > maxPoints) {\n            int step = Math.max(1, dataSize / maxPoints);\n            for (int i = 0; i < dataSize; i += step) {\n                displayLabels.add(labels.get(i));\n                displayPrices.add(prices.get(i));\n            }\n            // Add the last point\n            if (dataSize > 0 && (dataSize - 1) % step != 0) {\n                displayLabels.add(labels.get(dataSize - 1));\n                displayPrices.add(prices.get(dataSize - 1));\n            }\n        } else {\n            // Use all points for smaller datasets\n            displayLabels = labels;\n            displayPrices = prices;\n        }\n\n        // Limit X-axis labels to avoid overcrowding (max 15-20 labels)\n        int labelCount = displayLabels.size();\n        int maxLabels = 15; // Maximum number of labels to show on X-axis\n        if (labelCount > maxLabels) {\n            List<String> axisLabels = new ArrayList<>();\n            int labelStep = Math.max(1, labelCount / maxLabels);\n            for (int i = 0; i < labelCount; i++) {\n                if (i % labelStep == 0 || i == labelCount - 1) {\n                    axisLabels.add(displayLabels.get(i));\n                } else {\n                    axisLabels.add(\"\"); // Empty string to hide label\n                }\n            }\n            displayLabels = axisLabels;\n        }\n\n        chart.addSeries(\"Price\", displayLabels, displayPrices);\n        \n        return chart;\n    }\n\n    private CategoryChart createCandlestickChart(ChartViewModel viewModel) {\n        CategoryChart chart = new CategoryChartBuilder()\n                .width(getWidth() > 0 ? getWidth() - 20 : 600)\n                .height(getHeight() > 0 ? getHeight() - 20 : 400)\n                .title(viewModel.getTitle())\n                .xAxisTitle(\"Date\")\n                .yAxisTitle(\"Price (USD)\")\n                .build();\n\n        // For candlestick data, show only close price as a line chart for cleaner visualization\n        // This matches the UI design better\n        ChartStyler.applyLineChartStyle(chart);\n\n        List<String> labels = viewModel.getLabels();\n        List<Double> closePrices = viewModel.getClosePrices();\n        \n        // Sample data points based on time interval\n        int dataSize = labels.size();\n        List<String> displayLabels;\n        List<Double> displayPrices;\n        \n        // Determine max points based on interval\n        int maxPoints;\n        TimeInterval interval = viewModel.getInterval();\n        if (interval != null) {\n            switch (interval) {\n                case INTRADAY: // 5 minutes - show more detail\n                    maxPoints = 500;\n                    break;\n                case DAILY: // Daily - show moderate detail\n                    maxPoints = 100;\n                    break;\n                case WEEKLY: // Weekly - show less detail\n                    maxPoints = 50;\n                    break;\n                case MONTHLY: // Monthly - show minimal detail\n                    maxPoints = 30;\n                    break;\n                default:\n                    maxPoints = 200;\n            }\n        } else {\n            maxPoints = 200; // Default\n        }\n        \n        // Sample data points if needed\n        if (dataSize > maxPoints) {\n            int step = Math.max(1, dataSize / maxPoints);\n            displayLabels = new ArrayList<>();\n            displayPrices = new ArrayList<>();\n            for (int i = 0; i < dataSize; i += step) {\n                displayLabels.add(labels.get(i));\n                displayPrices.add(closePrices.get(i));\n            }\n            if (dataSize > 0 && (dataSize - 1) % step != 0) {\n                displayLabels.add(labels.get(dataSize - 1));\n                displayPrices.add(closePrices.get(dataSize - 1));\n            }\n        } else {\n            displayLabels = labels;\n            displayPrices = closePrices;\n        }\n\n        // Limit X-axis labels to avoid overcrowding (max 15-20 labels)\n        int labelCount = displayLabels.size();\n        int maxLabels = 15; // Maximum number of labels to show on X-axis\n        if (labelCount > maxLabels) {\n            List<String> axisLabels = new ArrayList<>();\n            int labelStep = Math.max(1, labelCount / maxLabels);\n            for (int i = 0; i < labelCount; i++) {\n                if (i % labelStep == 0 || i == labelCount - 1) {\n                    axisLabels.add(displayLabels.get(i));\n                } else {\n                    axisLabels.add(\"\"); // Empty string to hide label\n                }\n            }\n            displayLabels = axisLabels;\n        }\n\n        // Show only close price as a line chart (cleaner than showing all OHLC)\n        chart.addSeries(\"Price\", displayLabels, displayPrices);\n        \n        return chart;\n    }\n\n}\n\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/src/main/java/framework_and_driver/ChartPanel.java b/src/main/java/framework_and_driver/ChartPanel.java
--- a/src/main/java/framework_and_driver/ChartPanel.java	(revision 9a29da5965bc6935919a4d7bf65f137acf8f3e8e)
+++ b/src/main/java/framework_and_driver/ChartPanel.java	(date 1763851258809)
@@ -111,7 +111,7 @@
         TimeInterval interval = viewModel.getInterval();
         if (interval != null) {
             switch (interval) {
-                case INTRADAY: // 5 minutes - show more detail
+                case FIVE_MINUTES: // 5 minutes - show more detail
                     maxPoints = 500;
                     break;
                 case DAILY: // Daily - show moderate detail
@@ -195,7 +195,7 @@
         TimeInterval interval = viewModel.getInterval();
         if (interval != null) {
             switch (interval) {
-                case INTRADAY: // 5 minutes - show more detail
+                case FIVE_MINUTES: // 5 minutes - show more detail
                     maxPoints = 500;
                     break;
                 case DAILY: // Daily - show moderate detail
Index: .idea/workspace.xml
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+><?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<project version=\"4\">\n  <component name=\"AutoImportSettings\">\n    <option name=\"autoReloadType\" value=\"SELECTIVE\" />\n  </component>\n  <component name=\"ChangeListManager\">\n    <list default=\"true\" id=\"f5a27736-dc26-40a3-8ee3-4710d1bd7f3d\" name=\"Changes\" comment=\"\">\n      <change beforePath=\"$PROJECT_DIR$/pom.xml\" beforeDir=\"false\" afterPath=\"$PROJECT_DIR$/pom.xml\" afterDir=\"false\" />\n      <change beforePath=\"$PROJECT_DIR$/src/main/java/app/CompanyMain.java\" beforeDir=\"false\" afterPath=\"$PROJECT_DIR$/src/main/java/app/CompanyMain.java\" afterDir=\"false\" />\n      <change beforePath=\"$PROJECT_DIR$/src/main/java/entity/ChartViewModel.java\" beforeDir=\"false\" afterPath=\"$PROJECT_DIR$/src/main/java/entity/ChartViewModel.java\" afterDir=\"false\" />\n      <change beforePath=\"$PROJECT_DIR$/src/main/java/framework_and_driver/ChartWindow.java\" beforeDir=\"false\" afterPath=\"$PROJECT_DIR$/src/main/java/framework_and_driver/ChartWindow.java\" afterDir=\"false\" />\n      <change beforePath=\"$PROJECT_DIR$/src/main/java/framework_and_driver/CompanyDetailPage.java\" beforeDir=\"false\" afterPath=\"$PROJECT_DIR$/src/main/java/framework_and_driver/CompanyDetailPage.java\" afterDir=\"false\" />\n      <change beforePath=\"$PROJECT_DIR$/src/main/java/interface_adapter/CompanyDetailPresenter.java\" beforeDir=\"false\" afterPath=\"$PROJECT_DIR$/src/main/java/interface_adapter/CompanyDetailPresenter.java\" afterDir=\"false\" />\n      <change beforePath=\"$PROJECT_DIR$/src/main/java/interface_adapter/IntervalController.java\" beforeDir=\"false\" afterPath=\"$PROJECT_DIR$/src/main/java/interface_adapter/IntervalController.java\" afterDir=\"false\" />\n      <change beforePath=\"$PROJECT_DIR$/src/main/java/interface_adapter/PriceChartPresenter.java\" beforeDir=\"false\" afterPath=\"$PROJECT_DIR$/src/main/java/interface_adapter/PriceChartPresenter.java\" afterDir=\"false\" />\n    </list>\n    <option name=\"SHOW_DIALOG\" value=\"false\" />\n    <option name=\"HIGHLIGHT_CONFLICTS\" value=\"true\" />\n    <option name=\"HIGHLIGHT_NON_ACTIVE_CHANGELIST\" value=\"false\" />\n    <option name=\"LAST_RESOLUTION\" value=\"IGNORE\" />\n  </component>\n  <component name=\"Git.Settings\">\n    <option name=\"RECENT_GIT_ROOT_PATH\" value=\"$PROJECT_DIR$\" />\n  </component>\n  <component name=\"GitHubPullRequestSearchHistory\"><![CDATA[{\n  \"lastFilter\": {\n    \"state\": \"OPEN\",\n    \"assignee\": \"mirror-chen\"\n  }\n}]]></component>\n  <component name=\"GithubPullRequestsUISettings\"><![CDATA[{\n  \"selectedUrlAndAccountId\": {\n    \"url\": \"git@github.com:cwsengai/team-project.git\",\n    \"accountId\": \"597eafc1-ada2-4f1e-baa5-702e470fa0fe\"\n  }\n}]]></component>\n  <component name=\"ProjectColorInfo\"><![CDATA[{\n  \"associatedIndex\": 5\n}]]></component>\n  <component name=\"ProjectId\" id=\"35qCg5nggkMQ23hEztZfvTDIeOA\" />\n  <component name=\"ProjectViewState\">\n    <option name=\"hideEmptyMiddlePackages\" value=\"true\" />\n    <option name=\"showLibraryContents\" value=\"true\" />\n  </component>\n  <component name=\"PropertiesComponent\"><![CDATA[{\n  \"keyToString\": {\n    \"Application.CompanyMain.executor\": \"Run\",\n    \"Application.Main.executor\": \"Run\",\n    \"RunOnceActivity.ShowReadmeOnStart\": \"true\",\n    \"RunOnceActivity.git.unshallow\": \"true\",\n    \"git-widget-placeholder\": \"UC4chart\",\n    \"node.js.detected.package.eslint\": \"true\",\n    \"node.js.detected.package.tslint\": \"true\",\n    \"node.js.selected.package.eslint\": \"(autodetect)\",\n    \"node.js.selected.package.tslint\": \"(autodetect)\",\n    \"nodejs_package_manager_path\": \"npm\",\n    \"settings.editor.selected.configurable\": \"reference.settings.project.maven.repository.indices\",\n    \"vue.rearranger.settings.migration\": \"true\"\n  }\n}]]></component>\n  <component name=\"SharedIndexes\">\n    <attachedChunks>\n      <set>\n        <option value=\"bundled-jdk-9823dce3aa75-fbdcb00ec9e3-intellij.indexing.shared.core-IU-251.23774.435\" />\n        <option value=\"bundled-js-predefined-d6986cc7102b-f27c65a3e318-JavaScript-IU-251.23774.435\" />\n      </set>\n    </attachedChunks>\n  </component>\n  <component name=\"TaskManager\">\n    <task active=\"true\" id=\"Default\" summary=\"Default task\">\n      <changelist id=\"f5a27736-dc26-40a3-8ee3-4710d1bd7f3d\" name=\"Changes\" comment=\"\" />\n      <created>1763828325617</created>\n      <option name=\"number\" value=\"Default\" />\n      <option name=\"presentableId\" value=\"Default\" />\n      <updated>1763828325617</updated>\n      <workItem from=\"1763828327985\" duration=\"3242000\" />\n    </task>\n    <servers />\n  </component>\n  <component name=\"TypeScriptGeneratedFilesManager\">\n    <option name=\"version\" value=\"3\" />\n  </component>\n</project>
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/.idea/workspace.xml b/.idea/workspace.xml
--- a/.idea/workspace.xml	(revision 9a29da5965bc6935919a4d7bf65f137acf8f3e8e)
+++ b/.idea/workspace.xml	(date 1763850982168)
@@ -4,16 +4,7 @@
     <option name="autoReloadType" value="SELECTIVE" />
   </component>
   <component name="ChangeListManager">
-    <list default="true" id="f5a27736-dc26-40a3-8ee3-4710d1bd7f3d" name="Changes" comment="">
-      <change beforePath="$PROJECT_DIR$/pom.xml" beforeDir="false" afterPath="$PROJECT_DIR$/pom.xml" afterDir="false" />
-      <change beforePath="$PROJECT_DIR$/src/main/java/app/CompanyMain.java" beforeDir="false" afterPath="$PROJECT_DIR$/src/main/java/app/CompanyMain.java" afterDir="false" />
-      <change beforePath="$PROJECT_DIR$/src/main/java/entity/ChartViewModel.java" beforeDir="false" afterPath="$PROJECT_DIR$/src/main/java/entity/ChartViewModel.java" afterDir="false" />
-      <change beforePath="$PROJECT_DIR$/src/main/java/framework_and_driver/ChartWindow.java" beforeDir="false" afterPath="$PROJECT_DIR$/src/main/java/framework_and_driver/ChartWindow.java" afterDir="false" />
-      <change beforePath="$PROJECT_DIR$/src/main/java/framework_and_driver/CompanyDetailPage.java" beforeDir="false" afterPath="$PROJECT_DIR$/src/main/java/framework_and_driver/CompanyDetailPage.java" afterDir="false" />
-      <change beforePath="$PROJECT_DIR$/src/main/java/interface_adapter/CompanyDetailPresenter.java" beforeDir="false" afterPath="$PROJECT_DIR$/src/main/java/interface_adapter/CompanyDetailPresenter.java" afterDir="false" />
-      <change beforePath="$PROJECT_DIR$/src/main/java/interface_adapter/IntervalController.java" beforeDir="false" afterPath="$PROJECT_DIR$/src/main/java/interface_adapter/IntervalController.java" afterDir="false" />
-      <change beforePath="$PROJECT_DIR$/src/main/java/interface_adapter/PriceChartPresenter.java" beforeDir="false" afterPath="$PROJECT_DIR$/src/main/java/interface_adapter/PriceChartPresenter.java" afterDir="false" />
-    </list>
+    <list default="true" id="f5a27736-dc26-40a3-8ee3-4710d1bd7f3d" name="Changes" comment="" />
     <option name="SHOW_DIALOG" value="false" />
     <option name="HIGHLIGHT_CONFLICTS" value="true" />
     <option name="HIGHLIGHT_NON_ACTIVE_CHANGELIST" value="false" />
@@ -22,42 +13,42 @@
   <component name="Git.Settings">
     <option name="RECENT_GIT_ROOT_PATH" value="$PROJECT_DIR$" />
   </component>
-  <component name="GitHubPullRequestSearchHistory"><![CDATA[{
-  "lastFilter": {
-    "state": "OPEN",
-    "assignee": "mirror-chen"
+  <component name="GitHubPullRequestSearchHistory">{
+  &quot;lastFilter&quot;: {
+    &quot;state&quot;: &quot;OPEN&quot;,
+    &quot;assignee&quot;: &quot;mirror-chen&quot;
   }
-}]]></component>
-  <component name="GithubPullRequestsUISettings"><![CDATA[{
-  "selectedUrlAndAccountId": {
-    "url": "git@github.com:cwsengai/team-project.git",
-    "accountId": "597eafc1-ada2-4f1e-baa5-702e470fa0fe"
+}</component>
+  <component name="GithubPullRequestsUISettings">{
+  &quot;selectedUrlAndAccountId&quot;: {
+    &quot;url&quot;: &quot;git@github.com:cwsengai/team-project.git&quot;,
+    &quot;accountId&quot;: &quot;597eafc1-ada2-4f1e-baa5-702e470fa0fe&quot;
   }
-}]]></component>
-  <component name="ProjectColorInfo"><![CDATA[{
-  "associatedIndex": 5
-}]]></component>
+}</component>
+  <component name="ProjectColorInfo">{
+  &quot;associatedIndex&quot;: 5
+}</component>
   <component name="ProjectId" id="35qCg5nggkMQ23hEztZfvTDIeOA" />
   <component name="ProjectViewState">
     <option name="hideEmptyMiddlePackages" value="true" />
     <option name="showLibraryContents" value="true" />
   </component>
-  <component name="PropertiesComponent"><![CDATA[{
-  "keyToString": {
-    "Application.CompanyMain.executor": "Run",
-    "Application.Main.executor": "Run",
-    "RunOnceActivity.ShowReadmeOnStart": "true",
-    "RunOnceActivity.git.unshallow": "true",
-    "git-widget-placeholder": "UC4chart",
-    "node.js.detected.package.eslint": "true",
-    "node.js.detected.package.tslint": "true",
-    "node.js.selected.package.eslint": "(autodetect)",
-    "node.js.selected.package.tslint": "(autodetect)",
-    "nodejs_package_manager_path": "npm",
-    "settings.editor.selected.configurable": "reference.settings.project.maven.repository.indices",
-    "vue.rearranger.settings.migration": "true"
+  <component name="PropertiesComponent">{
+  &quot;keyToString&quot;: {
+    &quot;Application.CompanyMain.executor&quot;: &quot;Run&quot;,
+    &quot;Application.Main.executor&quot;: &quot;Run&quot;,
+    &quot;RunOnceActivity.ShowReadmeOnStart&quot;: &quot;true&quot;,
+    &quot;RunOnceActivity.git.unshallow&quot;: &quot;true&quot;,
+    &quot;git-widget-placeholder&quot;: &quot;UC4chart&quot;,
+    &quot;node.js.detected.package.eslint&quot;: &quot;true&quot;,
+    &quot;node.js.detected.package.tslint&quot;: &quot;true&quot;,
+    &quot;node.js.selected.package.eslint&quot;: &quot;(autodetect)&quot;,
+    &quot;node.js.selected.package.tslint&quot;: &quot;(autodetect)&quot;,
+    &quot;nodejs_package_manager_path&quot;: &quot;npm&quot;,
+    &quot;settings.editor.selected.configurable&quot;: &quot;reference.settings.project.maven.repository.indices&quot;,
+    &quot;vue.rearranger.settings.migration&quot;: &quot;true&quot;
   }
-}]]></component>
+}</component>
   <component name="SharedIndexes">
     <attachedChunks>
       <set>
