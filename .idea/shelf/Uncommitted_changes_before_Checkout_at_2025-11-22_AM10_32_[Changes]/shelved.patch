Index: team-project/src/main/java/interface_adapter/controller/simulated_trading/SimulatedTradingController.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>package interface_adapter.controller.simulated_trading;\nimport entity.PricePoint;\nimport entity.SimulatedOrder;\nimport entity.SimulatedTradeRecord;\nimport use_case.PriceDataAccessInterface;\nimport use_case.price_simulation.PriceSimulationEngine;\nimport use_case.simulated_trade.SimulatedTradeEngine;\nimport entity.TimeInterval;\n\n\nimport java.time.LocalDateTime;\nimport java.util.List;\n\npublic class TradingController {\n    // use case dependencies\n    private final PriceDataAccessInterface priceGateway;\n    private final PriceSimulationEngine simulationEngine;\n    private final SimulatedTradeEngine tradeEngine;\n    //runtime state\n    private SimulatedOrder currentOrder;\n    private List<Double> timeline;\n    private int pointer = 0;  // timeline pointer\n\n    public TradingController(PriceDataAccessInterface priceGateway,\n                             PriceSimulationEngine simulationEngine,\n                             SimulatedTradeEngine tradeEngine) {\n        this.priceGateway = priceGateway;\n        this.simulationEngine = simulationEngine;\n        this.tradeEngine = tradeEngine;\n    }\n\n    //  Smart Buying and Selling\n    public void onBuyOrSell(boolean isBuy, String ticker, int quantity, double limitPrice) {\n        if (currentOrder == null || !currentOrder.isFilled()) {\n            //If there is no current position, buying = going long and selling = going short\n            if (currentOrder == null || !currentOrder.isFilled()) {\n                if (isBuy) {\n                    openLong(ticker, quantity, limitPrice);\n                } else {\n                    openShort(ticker, quantity, limitPrice);\n                }\n                return;\n            }\n            // if currently in a long position: Sell = flat long\n            if (currentOrder.isLong()) {\n                if (!isBuy) {\n                    onClosePosition();\n                }\n            } else {\n                // if currently in a short position: buy = close out\n                if (isBuy) {\n                    onClosePosition();\n                }\n            }\n        }\n    }\n    private void openLong(String ticker, int qty, double limitPrice) {\n        System.out.println(\"Opening LONG position...\");\n        currentOrder = new SimulatedOrder(\n                newOrderId(),\n                ticker,\n                true,   // long\n                qty,\n                limitPrice,\n                LocalDateTime.now()\n        );\n    }\n\n    private void openShort(String ticker, int qty, double limitPrice) {\n        System.out.println(\"Opening SHORT position...\");\n        currentOrder = new SimulatedOrder(\n                newOrderId(),\n                ticker,\n                false,  // short\n                qty,\n                limitPrice,\n                LocalDateTime.now()\n        );\n    }\n    public void onStartSimulation(int compressionFactor) {\n\n        try {\n            //get 5min price\n            List<PricePoint> raw = priceGateway.getPriceHistory(\n                    currentOrder.getTicker(),\n                    TimeInterval.FIVE_MINUTES\n            );\n\n            // Set the compression factor of the price simulator\n            simulationEngine.setCompressionFactor(compressionFactor);\n            simulationEngine.loadRawData(raw);\n\n            // generate timeline\n            this.timeline = simulationEngine.generateTimeline();\n            this.pointer = 0;\n\n            System.out.println(\"Simulation started. Timeline size = \" + timeline.size());\n\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n\n    public void onTick() {\n\n        if (timeline == null || pointer >= timeline.size()) {\n            System.out.println(\"Simulation finished.\");\n            return;\n        }\n\n        double price = timeline.get(pointer);\n        pointer++;\n\n        //  If no transaction is made → Check if the limit price has been triggered\n        if (!currentOrder.isFilled()) {\n            boolean hit = tradeEngine.checkLimitHit(currentOrder, price);\n            if (hit) {\n                currentOrder.setFilled(true);\n                currentOrder.setEntryPrice(price);\n                System.out.println(\">>> ORDER FILLED @\" + price);\n            }\n        }\n\n        // === If the transaction has been completed → Display floating profit and loss ===\n        if (currentOrder.isFilled()) {\n            double pnl = tradeEngine.calculateUnrealizedPnL(currentOrder, price);\n            System.out.println(\"Price: \" + price + \" | PnL: \" + pnl);\n        }\n    }\n    public SimulatedTradeRecord onClosePosition() {\n\n        if (currentOrder == null || !currentOrder.isFilled()) {\n            System.out.println(\"ERROR: No position to close.\");\n            return null;\n        }\n\n        double exitPrice = timeline.get(Math.max(0, pointer - 1));\n        double realized = tradeEngine.calculateRealizedPnL(currentOrder, exitPrice);\n\n        SimulatedTradeRecord record = new SimulatedTradeRecord(\n                currentOrder.getTicker(),\n                currentOrder.isLong(),\n                currentOrder.getQuantity(),\n                currentOrder.getEntryPrice(),\n                exitPrice,\n                realized,\n                currentOrder.getEntryTime(),\n                LocalDateTime.now()\n        );\n\n        System.out.println(\">>> POSITION CLOSED @\" + exitPrice +\n                \"  Realized PnL=\" + realized);\n\n        currentOrder = null;  // reset position\n\n        return record;  // return to history reocrd\n    }\n\n\n\n    private String newOrderId() {\n        return \"ORDER-\" + System.currentTimeMillis();\n    }\n}\n
===================================================================
diff --git a/team-project/src/main/java/interface_adapter/controller/simulated_trading/SimulatedTradingController.java b/team-project/src/main/java/interface_adapter/controller/simulated_trading/SimulatedTradingController.java
--- a/team-project/src/main/java/interface_adapter/controller/simulated_trading/SimulatedTradingController.java	(revision 1b1050bc80b8f9ff0a40194c0e2584b6dc4b4f21)
+++ b/team-project/src/main/java/interface_adapter/controller/simulated_trading/SimulatedTradingController.java	(date 1763825390183)
@@ -83,7 +83,7 @@
             //get 5min price
             List<PricePoint> raw = priceGateway.getPriceHistory(
                     currentOrder.getTicker(),
-                    TimeInterval.FIVE_MINUTES
+                    TimeInterval.Five_Minute
             );
 
             // Set the compression factor of the price simulator
Index: team-project/src/main/java/data_access/PriceRepositoryTestSuite.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>package data_access;\n\nimport java.sql.Connection;\nimport java.sql.Statement;\nimport java.time.LocalDateTime;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Optional;\nimport java.util.UUID;\n\nimport entity.Company;\nimport entity.PricePoint;\nimport entity.TimeInterval;\n\n/**\n * Comprehensive test suite for PostgresPriceRepository.\n * Tests all CRUD operations, queries, and edge cases for price data.\n */\npublic class PriceRepositoryTestSuite {\n    \n    private static final PostgresPriceRepository priceRepo = new PostgresPriceRepository();\n    private static final PostgresCompanyRepository companyRepo = new PostgresCompanyRepository();\n    private static final PostgresClient client = new PostgresClient();\n    private static int testsRun = 0;\n    private static int testsPassed = 0;\n    private static int testsFailed = 0;\n    \n    // Test company IDs\n    private static String testCompanyId1;\n    private static String testCompanyId2;\n    \n    public static void main(String[] args) {\n        System.out.println(\"==========================================================\");\n        System.out.println(\"|    Price Repository Comprehensive Test Suite          |\");\n        System.out.println(\"==========================================================\\n\");\n        \n        try {\n            // Setup\n            System.out.println(\" Setup: Creating test companies and cleaning data...\");\n            setupTestData();\n            System.out.println(\"[OK] Setup complete\\n\");\n            \n            // Run all test categories\n            testBasicCRUD();\n            cleanupPriceData();\n            testLatestPriceQueries();\n            cleanupPriceData();\n            testHistoricalQueries();\n            cleanupPriceData();\n            testBulkOperations();\n            cleanupPriceData();\n            testEdgeCases();\n            cleanupPriceData();\n            testDataIntegrity();\n            cleanupPriceData();\n            testCleanup();\n            \n            // Summary\n            printSummary();\n            \n            // Cleanup\n            System.out.println(\"\\n Cleanup: Removing test data...\");\n            cleanupTestData();\n            System.out.println(\"[OK] Cleanup complete\");\n            \n            if (testsFailed > 0) {\n                System.exit(1);\n            }\n            \n        } catch (Exception e) {\n            System.err.println(\"\\n[ERROR] Test suite failed with exception: \" + e.getMessage());\n            e.printStackTrace();\n            System.exit(1);\n        }\n    }\n    \n    private static void testBasicCRUD() {\n        System.out.println(\"=======================================================\");\n        System.out.println(\"  1. BASIC CRUD OPERATIONS\");\n        System.out.println(\"=======================================================\\n\");\n        \n        // Test 1.1: Save single price point\n        runTest(\"Save single price point\", () -> {\n            PricePoint price = createTestPrice(\n                testCompanyId1,\n                LocalDateTime.now().minusDays(1),\n                TimeInterval.DAILY,\n                100.0, 105.0, 99.0, 103.0, 1000000.0\n            );\n            \n            priceRepo.savePricePoint(price);\n            \n            Optional<PricePoint> found = priceRepo.getLatestPrice(\"PRICE1\", TimeInterval.DAILY);\n            assertTrue(found.isPresent(), \"Price should be saved and retrievable\");\n            assertEqualsDouble(103.0, found.get().getClose(), \"Close price should match\");\n        });\n        \n        // Test 1.2: Save price with null values\n        runTest(\"Save price with null OHLV values\", () -> {\n            PricePoint price = new PricePoint(\n                UUID.randomUUID().toString(),\n                testCompanyId1,\n                LocalDateTime.now().minusHours(12),\n                TimeInterval.INTRADAY,\n                null, null, null,  // null open, high, low\n                50.0,              // only close\n                null,              // null volume\n                \"test\"\n            );\n            \n            priceRepo.savePricePoint(price);\n            // Should not throw exception\n        });\n        \n        // Test 1.3: Update existing price (upsert)\n        runTest(\"Update existing price via upsert\", () -> {\n            LocalDateTime timestamp = LocalDateTime.now().minusDays(2);\n            \n            PricePoint original = createTestPrice(\n                testCompanyId1, timestamp, TimeInterval.DAILY,\n                200.0, 205.0, 199.0, 202.0, 2000000.0\n            );\n            priceRepo.savePricePoint(original);\n            \n            // Update with same timestamp (should trigger upsert)\n            PricePoint updated = createTestPrice(\n                testCompanyId1, timestamp, TimeInterval.DAILY,\n                200.0, 210.0, 198.0, 208.0, 2500000.0\n            );\n            priceRepo.savePricePoint(updated);\n            \n            // Verify update\n            List<PricePoint> history = priceRepo.getHistoricalPrices(\n                \"PRICE1\",\n                timestamp.minusMinutes(1),\n                timestamp.plusMinutes(1),\n                TimeInterval.DAILY\n            );\n            \n            assertEqualsInt(1, history.size(), \"Should only have one price point at this timestamp\");\n            assertEqualsDouble(208.0, history.get(0).getClose(), \"Close should be updated\");\n            assertEqualsDouble(210.0, history.get(0).getHigh(), \"High should be updated\");\n        });\n    }\n    \n    private static void testLatestPriceQueries() {\n        System.out.println(\"\\n=======================================================\");\n        System.out.println(\"  2. LATEST PRICE QUERIES\");\n        System.out.println(\"=======================================================\\n\");\n        \n        // Test 2.1: Get latest price - finds most recent\n        runTest(\"Get latest price - returns most recent\", () -> {\n            // Setup: Create price history for this specific test\n            LocalDateTime base = LocalDateTime.now().minusDays(30);\n            for (int i = 0; i < 5; i++) {\n                priceRepo.savePricePoint(createTestPrice(\n                    testCompanyId1,\n                    base.plusDays(i),\n                    TimeInterval.DAILY,\n                    100.0 + i, 105.0 + i, 99.0 + i, 103.0 + i, 1000000.0\n                ));\n            }\n            \n            Optional<PricePoint> latest = priceRepo.getLatestPrice(\"PRICE1\", TimeInterval.DAILY);\n            assertTrue(latest.isPresent(), \"Should find latest price\");\n            assertEqualsDouble(107.0, latest.get().getClose(), \"Should return most recent close price\");\n        });\n        \n        // Test 2.2: Get latest price - different intervals\n        runTest(\"Get latest price - interval filtering\", () -> {\n            // Add intraday price\n            priceRepo.savePricePoint(createTestPrice(\n                testCompanyId1,\n                LocalDateTime.now().minusHours(1),\n                TimeInterval.INTRADAY,\n                150.0, 155.0, 149.0, 153.0, 500000.0\n            ));\n            \n            Optional<PricePoint> daily = priceRepo.getLatestPrice(\"PRICE1\", TimeInterval.DAILY);\n            Optional<PricePoint> intraday = priceRepo.getLatestPrice(\"PRICE1\", TimeInterval.INTRADAY);\n            \n            assertTrue(daily.isPresent(), \"Should find daily price\");\n            assertTrue(intraday.isPresent(), \"Should find intraday price\");\n            assertEqualsDouble(153.0, intraday.get().getClose(), \"Intraday close should be 153\");\n        });\n        \n        // Test 2.3: Get latest price - no data\n        runTest(\"Get latest price - ticker not found\", () -> {\n            Optional<PricePoint> notFound = priceRepo.getLatestPrice(\"NONEXISTENT\", TimeInterval.DAILY);\n            assertFalse(notFound.isPresent(), \"Should not find price for non-existent ticker\");\n        });\n        \n        // Test 2.4: Get latest prices - multiple tickers\n        runTest(\"Get latest prices - bulk query\", () -> {\n            // Add price for second company\n            priceRepo.savePricePoint(createTestPrice(\n                testCompanyId2,\n                LocalDateTime.now().minusDays(1),\n                TimeInterval.DAILY,\n                50.0, 52.0, 49.0, 51.0, 800000.0\n            ));\n            \n            Map<String, PricePoint> prices = priceRepo.getLatestPrices(\n                List.of(\"PRICE1\", \"PRICE2\")\n            );\n            \n            assertEqualsInt(2, prices.size(), \"Should find prices for both tickers\");\n            assertTrue(prices.containsKey(\"PRICE1\"), \"Should contain PRICE1\");\n            assertTrue(prices.containsKey(\"PRICE2\"), \"Should contain PRICE2\");\n            assertEqualsDouble(51.0, prices.get(\"PRICE2\").getClose(), \"PRICE2 close should be 51\");\n        });\n        \n        // Test 2.5: Get latest prices - empty list\n        runTest(\"Get latest prices - empty ticker list\", () -> {\n            Map<String, PricePoint> prices = priceRepo.getLatestPrices(List.of());\n            assertEqualsInt(0, prices.size(), \"Should return empty map for empty input\");\n        });\n    }\n    \n    private static void testHistoricalQueries() {\n        System.out.println(\"\\n=======================================================\");\n        System.out.println(\"  3. HISTORICAL PRICE QUERIES\");\n        System.out.println(\"=======================================================\\n\");\n        \n        // Test 3.1: Get historical prices - date range\n        runTest(\"Get historical prices - date range\", () -> {\n            // Setup: Create test data\n            LocalDateTime base = LocalDateTime.now().minusDays(40);\n            for (int i = 0; i < 5; i++) {\n                priceRepo.savePricePoint(createTestPrice(\n                    testCompanyId1,\n                    base.plusDays(i),\n                    TimeInterval.DAILY,\n                    100.0 + i, 105.0 + i, 99.0 + i, 103.0 + i, 1000000.0\n                ));\n            }\n            \n            LocalDateTime start = base;\n            LocalDateTime end = base.plusDays(4);\n            \n            List<PricePoint> history = priceRepo.getHistoricalPrices(\n                \"PRICE1\", start, end, TimeInterval.DAILY\n            );\n            \n            assertTrue(history.size() >= 2, \"Should find prices in range\");\n            // Verify ascending order\n            for (int i = 1; i < history.size(); i++) {\n                assertTrue(\n                    history.get(i).getTimestamp().isAfter(history.get(i - 1).getTimestamp()),\n                    \"Prices should be in ascending timestamp order\"\n                );\n            }\n        });\n        \n        // Test 3.2: Get historical prices - empty range\n        runTest(\"Get historical prices - no data in range\", () -> {\n            LocalDateTime start = LocalDateTime.now().plusDays(10);\n            LocalDateTime end = LocalDateTime.now().plusDays(20);\n            \n            List<PricePoint> history = priceRepo.getHistoricalPrices(\n                \"PRICE1\", start, end, TimeInterval.DAILY\n            );\n            \n            assertEqualsInt(0, history.size(), \"Should return empty list for future dates\");\n        });\n        \n        // Test 3.3: Get historical prices - single day\n        runTest(\"Get historical prices - single day\", () -> {\n            LocalDateTime day = LocalDateTime.now().minusDays(50).withHour(12).withMinute(0).withSecond(0).withNano(0);\n            \n            // Add a price on that specific day\n            priceRepo.savePricePoint(createTestPrice(\n                testCompanyId1,\n                day,\n                TimeInterval.DAILY,\n                100.0, 105.0, 99.0, 103.0, 1000000.0\n            ));\n            \n            List<PricePoint> history = priceRepo.getHistoricalPrices(\n                \"PRICE1\",\n                day,\n                day.plusDays(1),\n                TimeInterval.DAILY\n            );\n            \n            assertTrue(history.size() >= 1, \"Should find at least one price for the day\");\n        });\n    }\n    \n    private static void testBulkOperations() {\n        System.out.println(\"\\n=======================================================\");\n        System.out.println(\"  4. BULK OPERATIONS\");\n        System.out.println(\"=======================================================\\n\");\n        \n        // Test 4.1: Bulk save multiple price points\n        runTest(\"Bulk save - multiple price points\", () -> {\n            List<PricePoint> prices = new java.util.ArrayList<>();\n            LocalDateTime base = LocalDateTime.now().minusDays(20);\n            \n            for (int i = 0; i < 10; i++) {\n                prices.add(createTestPrice(\n                    testCompanyId2,\n                    base.plusDays(i),\n                    TimeInterval.DAILY,\n                    60.0 + i, 62.0 + i, 59.0 + i, 61.0 + i, 900000.0\n                ));\n            }\n            \n            priceRepo.savePricePoints(prices);\n            \n            List<PricePoint> saved = priceRepo.getHistoricalPrices(\n                \"PRICE2\",\n                base.minusDays(1),\n                base.plusDays(11),\n                TimeInterval.DAILY\n            );\n            \n            assertTrue(saved.size() >= 10, \"Should save all 10 price points\");\n        });\n        \n        // Test 4.2: Bulk save empty list\n        runTest(\"Bulk save - empty list\", () -> {\n            priceRepo.savePricePoints(List.of());\n            // Should not throw exception\n        });\n    }\n    \n    private static void testEdgeCases() {\n        System.out.println(\"\\n=======================================================\");\n        System.out.println(\"  5. EDGE CASES\");\n        System.out.println(\"=======================================================\\n\");\n        \n        // Test 5.1: Very large prices\n        runTest(\"Handle very large price values\", () -> {\n            PricePoint huge = createTestPrice(\n                testCompanyId1,\n                LocalDateTime.now().minusMinutes(5),\n                TimeInterval.INTRADAY,\n                999999999.99, 1000000000.0, 999999999.0, 999999999.99, 100000000000.0\n            );\n            \n            priceRepo.savePricePoint(huge);\n            // Should not throw exception\n        });\n        \n        // Test 5.2: Very small/fractional prices\n        runTest(\"Handle fractional penny prices\", () -> {\n            PricePoint tiny = createTestPrice(\n                testCompanyId1,\n                LocalDateTime.now().minusMinutes(10),\n                TimeInterval.INTRADAY,\n                0.0001, 0.0002, 0.0001, 0.00015, 100.0\n            );\n            \n            priceRepo.savePricePoint(tiny);\n            \n            Optional<PricePoint> found = priceRepo.getLatestPrice(\"PRICE1\", TimeInterval.INTRADAY);\n            assertTrue(found.isPresent(), \"Should save tiny prices\");\n        });\n        \n        // Test 5.3: Different time intervals\n        runTest(\"Handle all time intervals\", () -> {\n            LocalDateTime now = LocalDateTime.now();\n            \n            for (TimeInterval interval : TimeInterval.values()) {\n                PricePoint price = createTestPrice(\n                    testCompanyId1, now.minusHours(1), interval,\n                    100.0, 101.0, 99.0, 100.5, 1000.0\n                );\n                priceRepo.savePricePoint(price);\n            }\n            \n            // Verify each interval saved\n            for (TimeInterval interval : TimeInterval.values()) {\n                Optional<PricePoint> found = priceRepo.getLatestPrice(\"PRICE1\", interval);\n                assertTrue(found.isPresent(), \"Should save price for \" + interval);\n            }\n        });\n    }\n    \n    private static void testDataIntegrity() {\n        System.out.println(\"\\n=======================================================\");\n        System.out.println(\"  6. DATA INTEGRITY\");\n        System.out.println(\"=======================================================\\n\");\n        \n        // Test 6.1: Unique constraint (company_id, interval, timestamp)\n        runTest(\"Unique constraint enforcement\", () -> {\n            LocalDateTime timestamp = LocalDateTime.now().minusMinutes(30);\n            \n            PricePoint first = createTestPrice(\n                testCompanyId1, timestamp, TimeInterval.DAILY,\n                110.0, 115.0, 109.0, 113.0, 1100000.0\n            );\n            priceRepo.savePricePoint(first);\n            \n            // Try to insert duplicate (should upsert/update)\n            PricePoint duplicate = createTestPrice(\n                testCompanyId1, timestamp, TimeInterval.DAILY,\n                110.0, 116.0, 108.0, 114.0, 1200000.0\n            );\n            priceRepo.savePricePoint(duplicate);\n            \n            List<PricePoint> atTimestamp = priceRepo.getHistoricalPrices(\n                \"PRICE1\",\n                timestamp.minusSeconds(1),\n                timestamp.plusSeconds(1),\n                TimeInterval.DAILY\n            );\n            \n            assertEqualsInt(1, atTimestamp.size(), \"Should only have one price at exact timestamp\");\n            assertEqualsDouble(114.0, atTimestamp.get(0).getClose(), \"Should have updated value\");\n        });\n        \n        // Test 6.2: OHLC validation (high >= low)\n        runTest(\"OHLC data consistency\", () -> {\n            PricePoint valid = createTestPrice(\n                testCompanyId1,\n                LocalDateTime.now().minusMinutes(15),\n                TimeInterval.DAILY,\n                100.0, 105.0, 95.0, 102.0, 1000.0\n            );\n            priceRepo.savePricePoint(valid);\n            \n            Optional<PricePoint> found = priceRepo.getLatestPrice(\"PRICE1\", TimeInterval.DAILY);\n            assertTrue(found.isPresent(), \"Valid OHLC should save\");\n            \n            PricePoint p = found.get();\n            assertTrue(p.getHigh() >= p.getLow(), \"High should be >= Low\");\n            assertTrue(p.getHigh() >= p.getOpen(), \"High should be >= Open\");\n            assertTrue(p.getHigh() >= p.getClose(), \"High should be >= Close\");\n            assertTrue(p.getLow() <= p.getOpen(), \"Low should be <= Open\");\n            assertTrue(p.getLow() <= p.getClose(), \"Low should be <= Close\");\n        });\n    }\n    \n    private static void testCleanup() {\n        System.out.println(\"\\n=======================================================\");\n        System.out.println(\"  7. CLEANUP OPERATIONS\");\n        System.out.println(\"=======================================================\\n\");\n        \n        // Test 7.1: Cleanup old data\n        runTest(\"Cleanup old price data\", () -> {\n            // Add some very old prices\n            LocalDateTime veryOld = LocalDateTime.now().minusYears(5);\n            for (int i = 0; i < 3; i++) {\n                priceRepo.savePricePoint(createTestPrice(\n                    testCompanyId1, veryOld.plusDays(i), TimeInterval.DAILY,\n                    50.0, 51.0, 49.0, 50.5, 500.0\n                ));\n            }\n            \n            // Cleanup data older than 1 year\n            priceRepo.cleanup(LocalDateTime.now().minusYears(1));\n            \n            // Verify old data removed\n            List<PricePoint> oldData = priceRepo.getHistoricalPrices(\n                \"PRICE1\",\n                veryOld.minusDays(1),\n                veryOld.plusDays(10),\n                TimeInterval.DAILY\n            );\n            \n            assertEqualsInt(0, oldData.size(), \"Old data should be removed\");\n        });\n    }\n    \n    // ===== Test Utilities =====\n    \n    private static PricePoint createTestPrice(String companyId, LocalDateTime timestamp,\n                                               TimeInterval interval, double open, double high,\n                                               double low, double close, double volume) {\n        return new PricePoint(\n            UUID.randomUUID().toString(),\n            companyId,\n            timestamp,\n            interval,\n            open, high, low, close, volume,\n            \"test-source\"\n        );\n    }\n    \n    private static void setupTestData() {\n        cleanupTestData();\n        \n        // Create test companies\n        Company company1 = new Company(\n            \"PRICE1\",\n            \"Price Test Company 1\",\n            \"Test company for price data\",\n            1000000000.0,\n            15.0\n        );\n        company1.setSector(\"Technology\");\n        company1.setIndustry(\"Software\");\n        companyRepo.save(company1);\n        testCompanyId1 = company1.getSymbol();\n        \n        Company company2 = new Company(\n            \"PRICE2\",\n            \"Price Test Company 2\",\n            \"Test company for price data\",\n            2000000000.0,\n            20.0\n        );\n        company2.setSector(\"Finance\");\n        company2.setIndustry(\"Banking\");\n        companyRepo.save(company2);\n        testCompanyId2 = company2.getSymbol();\n    }\n    \n    private static void cleanupTestData() {\n        try (Connection conn = client.getConnection();\n             Statement stmt = conn.createStatement()) {\n            // Delete test prices\n            stmt.execute(\"DELETE FROM public.price_points WHERE source = 'test-source' OR source = 'test'\");\n            // Delete test companies\n            stmt.execute(\"DELETE FROM public.companies WHERE ticker LIKE 'PRICE%'\");\n        } catch (Exception e) {\n            System.err.println(\"Warning: Cleanup failed - \" + e.getMessage());\n        }\n    }\n    \n    private static void cleanupPriceData() {\n        try (Connection conn = client.getConnection();\n             Statement stmt = conn.createStatement()) {\n            // Delete only test prices, keep companies\n            stmt.execute(\"DELETE FROM public.price_points WHERE source = 'test-source' OR source = 'test'\");\n        } catch (Exception e) {\n            System.err.println(\"Warning: Price cleanup failed - \" + e.getMessage());\n        }\n    }\n    \n    private static void runTest(String testName, Runnable test) {\n        testsRun++;\n        try {\n            test.run();\n            testsPassed++;\n            System.out.println(\"[OK] \" + testName);\n        } catch (AssertionError e) {\n            testsFailed++;\n            System.out.println(\"[FAIL] \" + testName);\n            System.out.println(\"  Error: \" + e.getMessage());\n        } catch (Exception e) {\n            testsFailed++;\n            System.out.println(\"[FAIL] \" + testName);\n            System.out.println(\"  Exception: \" + e.getMessage());\n            e.printStackTrace();\n        }\n    }\n    \n    private static void assertTrue(boolean condition, String message) {\n        if (!condition) {\n            throw new AssertionError(message);\n        }\n    }\n    \n    private static void assertFalse(boolean condition, String message) {\n        if (condition) {\n            throw new AssertionError(message);\n        }\n    }\n    \n    private static void assertEqualsStr(String expected, String actual, String message) {\n        if (expected == null && actual == null) return;\n        if (expected == null || !expected.equals(actual)) {\n            throw new AssertionError(message + \" (expected: \" + expected + \", actual: \" + actual + \")\");\n        }\n    }\n    \n    private static void assertEqualsDouble(double expected, double actual, String message) {\n        if (Math.abs(expected - actual) > 0.01) {\n            throw new AssertionError(message + \" (expected: \" + expected + \", actual: \" + actual + \")\");\n        }\n    }\n    \n    private static void assertEqualsInt(int expected, int actual, String message) {\n        if (expected != actual) {\n            throw new AssertionError(message + \" (expected: \" + expected + \", actual: \" + actual + \")\");\n        }\n    }\n    \n    private static void printSummary() {\n        System.out.println(\"\\n==========================================================\");\n        System.out.println(\"|                    TEST SUMMARY                        |\");\n        System.out.println(\"==========================================================\");\n        System.out.printf(\"|  Total Tests:  %-40d|%n\", testsRun);\n        System.out.printf(\"|  Passed:       %-40d|%n\", testsPassed);\n        System.out.printf(\"|  Failed:       %-40d|%n\", testsFailed);\n        System.out.printf(\"|  Success Rate: %-39.1f%%|%n\", (testsRun > 0 ? (testsPassed * 100.0 / testsRun) : 0));\n        System.out.println(\"==========================================================\");\n        \n        if (testsFailed == 0) {\n            System.out.println(\"\\n*** All tests passed!\");\n        } else {\n            System.out.println(\"\\nWARNING:  Some tests failed. Please review the output above.\");\n        }\n    }\n}\n
===================================================================
diff --git a/team-project/src/main/java/data_access/PriceRepositoryTestSuite.java b/team-project/src/main/java/data_access/PriceRepositoryTestSuite.java
--- a/team-project/src/main/java/data_access/PriceRepositoryTestSuite.java	(revision 1b1050bc80b8f9ff0a40194c0e2584b6dc4b4f21)
+++ b/team-project/src/main/java/data_access/PriceRepositoryTestSuite.java	(date 1763825419553)
@@ -101,7 +101,7 @@
                 UUID.randomUUID().toString(),
                 testCompanyId1,
                 LocalDateTime.now().minusHours(12),
-                TimeInterval.INTRADAY,
+                TimeInterval.Five_Minute,
                 null, null, null,  // null open, high, low
                 50.0,              // only close
                 null,              // null volume
@@ -168,20 +168,20 @@
         
         // Test 2.2: Get latest price - different intervals
         runTest("Get latest price - interval filtering", () -> {
-            // Add intraday price
+            // Add Five_Minute price
             priceRepo.savePricePoint(createTestPrice(
                 testCompanyId1,
                 LocalDateTime.now().minusHours(1),
-                TimeInterval.INTRADAY,
+                TimeInterval.Five_Minute,
                 150.0, 155.0, 149.0, 153.0, 500000.0
             ));
             
             Optional<PricePoint> daily = priceRepo.getLatestPrice("PRICE1", TimeInterval.DAILY);
-            Optional<PricePoint> intraday = priceRepo.getLatestPrice("PRICE1", TimeInterval.INTRADAY);
+            Optional<PricePoint> fiveMinute = priceRepo.getLatestPrice("PRICE1", TimeInterval.Five_Minute);
             
             assertTrue(daily.isPresent(), "Should find daily price");
-            assertTrue(intraday.isPresent(), "Should find intraday price");
-            assertEqualsDouble(153.0, intraday.get().getClose(), "Intraday close should be 153");
+            assertTrue(fiveMinute.isPresent(), "Should find Five_Minute price");
+            assertEqualsDouble(153.0, fiveMinute.get().getClose(), "Five_Minute close should be 153");
         });
         
         // Test 2.3: Get latest price - no data
@@ -335,7 +335,7 @@
             PricePoint huge = createTestPrice(
                 testCompanyId1,
                 LocalDateTime.now().minusMinutes(5),
-                TimeInterval.INTRADAY,
+                TimeInterval.Five_Minute,
                 999999999.99, 1000000000.0, 999999999.0, 999999999.99, 100000000000.0
             );
             
@@ -348,13 +348,13 @@
             PricePoint tiny = createTestPrice(
                 testCompanyId1,
                 LocalDateTime.now().minusMinutes(10),
-                TimeInterval.INTRADAY,
+                TimeInterval.Five_Minute,
                 0.0001, 0.0002, 0.0001, 0.00015, 100.0
             );
             
             priceRepo.savePricePoint(tiny);
             
-            Optional<PricePoint> found = priceRepo.getLatestPrice("PRICE1", TimeInterval.INTRADAY);
+            Optional<PricePoint> found = priceRepo.getLatestPrice("PRICE1", TimeInterval.Five_Minute);
             assertTrue(found.isPresent(), "Should save tiny prices");
         });
         
